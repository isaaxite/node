比较重要的点：

- internalBinding链接javascript代码与C++代码
```js
// 链接 node/src/node_http_parser.cc
const { methods, HTTPParser } = internalBinding('http_parser');
```


创建一个http服务

一般使用http.createServer((req, resp) => {}) 创建一个http服务，其实就是创建一个 Server的实例, 由下文可见http.createServer接受2个参数，opts和requestListener，而当只传入一个函数时，这个函数就会被当作requestListener使用。
这个requestListener则是会用作 'request'事件的回调函数，'request'事件在Server构造函数内绑定。
'request'事件什么时候触发？全局搜索可以见到在parserOnIncoming函数中被触发。
再次全局搜索 parserOnIncoming，发现它被在connectionListenerInternal中使用：
` parser.onIncoming = FunctionPrototypeBind(parserOnIncoming, undefined, server, socket, state);`
对connectionListenerInternal向上回溯，它在Server构造函数内绑定在‘connection’事件：`this.on('connection', connectionListener);`
那么`parser.onIncoming`又是在哪里被调用？
追溯parser是什么！parser在connectionListenerInternal中由`const parser = parsers.alloc();`得到，追溯到`_http_common.js`知道parsers是HTTPParser的实例：`const parser = new HTTPParser();`，他的实例方法`parserOnHeadersComplete`中的最后就调用了`parser.onIncoming`：`return parser.onIncoming(incoming, shouldKeepAlive);`
再看parserOnIncoming的形参：`function parserOnIncoming(server, socket, state, req, keepAlive)`，前三个都是被绑定了的，对比parser.onIncoming的实参，可以知道`incoming`就是 `req`！
`incoming` 就是解析出来的 req对象
那么 `incoming` 是什么？
再 `parserOnHeadersComplete` 中可知 `incoming` 是基于socket创建的`ParserIncomingMessage`实例：`const incoming = parser.incoming = new ParserIncomingMessage(socket);`
```js
const ParserIncomingMessage = (socket && socket.server &&
                              socket.server[kIncomingMessage]) ||
                              IncomingMessage;
```

参考：
- https://zhuanlan.zhihu.com/p/60552748


```js
// 用户实现
http.createServer(() => {
  // 省略
});

// path: node/lib/http.js
function createServer(opts, requestListener) {
  return new Server(opts, requestListener);
}
```
con
监听 request 事件
```js
// path: node/lib/_http_server.js
function Server(options, requestListener) {
  if (!(this instanceof Server)) return new Server(options, requestListener);

  if (typeof options === 'function') {
    requestListener = options;
    options = {};
  } else if (options == null || typeof options === 'object') {
    options = { ...options };
  } else {
    throw new ERR_INVALID_ARG_TYPE('options', 'object', options);
  }

  this[kIncomingMessage] = options.IncomingMessage || IncomingMessage;
  this[kServerResponse] = options.ServerResponse || ServerResponse;

  const maxHeaderSize = options.maxHeaderSize;
  if (maxHeaderSize !== undefined)
    validateInteger(maxHeaderSize, 'maxHeaderSize', 0);
  this.maxHeaderSize = maxHeaderSize;

  const insecureHTTPParser = options.insecureHTTPParser;
  if (insecureHTTPParser !== undefined)
    validateBoolean(insecureHTTPParser, 'options.insecureHTTPParser');
  this.insecureHTTPParser = insecureHTTPParser;

  // 调用父类的构造函数
  // FunctionPrototypeCall = Function.proptotype.call
  // 传入 当前上下文this 调用 net.Server 构造函数
  // ! 注意：这里是没有传入 connectionListener，所以启动http服务时，应该是没有监听 net.Server 的 connection 事件
  FunctionPrototypeCall(net.Server, this, { allowHalfOpen: true });

  if (requestListener) {
    this.on('request', requestListener);
  }

  // Similar option to this. Too lazy to write my own docs.
  // http://www.squid-cache.org/Doc/config/half_closed_clients/
  // https://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F
  this.httpAllowHalfOpen = false;

  // 监听  connection 事件， 处理socket回报
  this.on('connection', connectionListener);

  this.timeout = 0;
  this.keepAliveTimeout = 5000;
  this.maxHeadersCount = null;
  this.headersTimeout = 60 * 1000; // 60 seconds
  this.requestTimeout = 0;
}
ObjectSetPrototypeOf(Server.prototype, net.Server.prototype);
ObjectSetPrototypeOf(Server, net.Server);
```

connectionListener 的函数体逻辑

函数体中通过 socket.on('data', state.onData); 接收数据

```js
function connectionListener(socket) {
  defaultTriggerAsyncIdScope(
    getOrSetAsyncId(socket), connectionListenerInternal, this, socket
  );
}

function connectionListenerInternal(server, socket) {
  debug('SERVER new http connection');

  // Ensure that the server property of the socket is correctly set.
  // See https://github.com/nodejs/node/issues/13435
  socket.server = server;

  // If the user has added a listener to the server,
  // request, or response, then it's their responsibility.
  // otherwise, destroy on timeout by default
  if (server.timeout && typeof socket.setTimeout === 'function')
    socket.setTimeout(server.timeout);
  socket.on('timeout', socketOnTimeout);

  const parser = parsers.alloc();

  // TODO(addaleax): This doesn't play well with the
  // `async_hooks.currentResource()` proposal, see
  // https://github.com/nodejs/node/pull/21313
  parser.initialize(
    HTTPParser.REQUEST,
    new HTTPServerAsyncResource('HTTPINCOMINGMESSAGE', socket),
    server.maxHeaderSize || 0,
    server.insecureHTTPParser === undefined ?
      isLenient() : server.insecureHTTPParser,
    server.headersTimeout || 0,
  );
  parser.socket = socket;
  socket.parser = parser;

  // Propagate headers limit from server instance to parser
  if (typeof server.maxHeadersCount === 'number') {
    parser.maxHeaderPairs = server.maxHeadersCount << 1;
  }

  const state = {
    onData: null,
    onEnd: null,
    onClose: null,
    onDrain: null,
    outgoing: [],
    incoming: [],
    // `outgoingData` is an approximate amount of bytes queued through all
    // inactive responses. If more data than the high watermark is queued - we
    // need to pause TCP socket/HTTP parser, and wait until the data will be
    // sent to the client.
    outgoingData: 0,
    keepAliveTimeoutSet: false
  };
  state.onData = FunctionPrototypeBind(socketOnData, undefined,
                                       server, socket, parser, state);
  state.onEnd = FunctionPrototypeBind(socketOnEnd, undefined,
                                      server, socket, parser, state);
  state.onClose = FunctionPrototypeBind(socketOnClose, undefined,
                                        socket, state);
  state.onDrain = FunctionPrototypeBind(socketOnDrain, undefined,
                                        socket, state);
  socket.on('data', state.onData);
  socket.on('error', socketOnError);
  socket.on('end', state.onEnd);
  socket.on('close', state.onClose);
  socket.on('drain', state.onDrain);
  parser.onIncoming = FunctionPrototypeBind(parserOnIncoming, undefined,
                                            server, socket, state);

  // We are consuming socket, so it won't get any actual data
  socket.on('resume', onSocketResume);
  socket.on('pause', onSocketPause);

  // Overrides to unconsume on `data`, `readable` listeners
  socket.on = generateSocketListenerWrapper('on');
  socket.addListener = generateSocketListenerWrapper('addListener');
  socket.prependListener = generateSocketListenerWrapper('prependListener');
  socket.setEncoding = socketSetEncoding;

  // We only consume the socket if it has never been consumed before.
  if (socket._handle && socket._handle.isStreamBase &&
      !socket._handle._consumed) {
    parser._consumed = true;
    socket._handle._consumed = true;
    parser.consume(socket._handle);
  }
  parser[kOnExecute] =
    FunctionPrototypeBind(onParserExecute, undefined,
                          server, socket, parser, state);

  parser[kOnTimeout] =
    FunctionPrototypeBind(onParserTimeout, undefined,
                          server, socket);

  // When receiving new requests on the same socket (pipelining or keep alive)
  // make sure the requestTimeout is active.
  parser[kOnMessageBegin] =
    FunctionPrototypeBind(setRequestTimeout, undefined,
                          server, socket);

  // This protects from DOS attack where an attacker establish the connection
  // without sending any data on applications where server.timeout is left to
  // the default value of zero.
  setRequestTimeout(server, socket);

  socket._paused = false;
}
```
`state.onData = FunctionPrototypeBind(socketOnData, undefined, server, socket, parser, state);` 
`FunctionPrototypeBind(socketOnData, undefined, server, socket, parser, state)` 基于socketOnData生产出一个 data 事件的回调函数
```js
// d 就是 data 事件回调函数的回参 `<Buffer> | <string>`
function socketOnData(server, socket, parser, state, d) {
  assert(!socket._paused);
  debug('SERVER socketOnData %d', d.length);

  const ret = parser.execute(d);
  onParserExecuteCommon(server, socket, parser, state, ret, d);
}
```

触发 request 事件

```js
// path: node/lib/_http_server.js
// The following callback is issued after the headers have been read on a
// new message. In this callback we setup the response object and pass it
// to the user.
function parserOnIncoming(server, socket, state, req, keepAlive) {
  resetSocketTimeout(server, socket, state);

  if (req.upgrade) {
    req.upgrade = req.method === 'CONNECT' ||
                  server.listenerCount('upgrade') > 0;
    if (req.upgrade)
      return 2;
  }

  ArrayPrototypePush(state.incoming, req);

  // If the writable end isn't consuming, then stop reading
  // so that we don't become overwhelmed by a flood of
  // pipelined requests that may never be resolved.
  if (!socket._paused) {
    const ws = socket._writableState;
    if (ws.needDrain || state.outgoingData >= socket.writableHighWaterMark) {
      socket._paused = true;
      // We also need to pause the parser, but don't do that until after
      // the call to execute, because we may still be processing the last
      // chunk.
      socket.pause();
    }
  }

  const res = new server[kServerResponse](req);
  res._keepAliveTimeout = server.keepAliveTimeout;
  res._onPendingData = FunctionPrototypeBind(updateOutgoingData, undefined,
                                             socket, state);

  res.shouldKeepAlive = keepAlive;
  DTRACE_HTTP_SERVER_REQUEST(req, socket);

  if (onRequestStartChannel.hasSubscribers) {
    onRequestStartChannel.publish({
      request: req,
      response: res,
      socket,
      server
    });
  }

  if (socket._httpMessage) {
    // There are already pending outgoing res, append.
    ArrayPrototypePush(state.outgoing, res);
  } else {
    res.assignSocket(socket);
  }

  // When we're finished writing the response, check if this is the last
  // response, if so destroy the socket.
  res.on('finish',
         FunctionPrototypeBind(resOnFinish, undefined,
                               req, res, socket, state, server));

  if (req.headers.expect !== undefined &&
      (req.httpVersionMajor === 1 && req.httpVersionMinor === 1)) {
    if (RegExpPrototypeTest(continueExpression, req.headers.expect)) {
      res._expect_continue = true;

      if (server.listenerCount('checkContinue') > 0) {
        server.emit('checkContinue', req, res);
      } else {
        res.writeContinue();
        server.emit('request', req, res);
      }
    } else if (server.listenerCount('checkExpectation') > 0) {
      server.emit('checkExpectation', req, res);
    } else {
      res.writeHead(417);
      res.end();
    }
  } else {
    req.on('end', clearRequestTimeout);

    server.emit('request', req, res);
  }
  return 0;  // No special treatment.
}
```

net.js
监听 connection 事件

```js
function Server(options, connectionListener) {
  if (!(this instanceof Server))
    return new Server(options, connectionListener);

  FunctionPrototypeCall(EventEmitter, this);

  if (typeof options === 'function') {
    connectionListener = options;
    options = {};
    this.on('connection', connectionListener);
  } else if (options == null || typeof options === 'object') {
    options = { ...options };

    if (typeof connectionListener === 'function') {
      this.on('connection', connectionListener);
    }
  } else {
    throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
  }

  this._connections = 0;

  this[async_id_symbol] = -1;
  this._handle = null;
  this._usingWorkers = false;
  this._workers = [];
  this._unref = false;

  this.allowHalfOpen = options.allowHalfOpen || false;
  this.pauseOnConnect = !!options.pauseOnConnect;
}
ObjectSetPrototypeOf(Server.prototype, EventEmitter.prototype);
ObjectSetPrototypeOf(Server, EventEmitter);
```


触发 connection 事件

```js
this._handle.onconnection = onconnection;

function onconnection(err, clientHandle) {
  const handle = this;
  const self = handle[owner_symbol];

  debug('onconnection');

  if (err) {
    self.emit('error', errnoException(err, 'accept'));
    return;
  }

  if (self.maxConnections && self._connections >= self.maxConnections) {
    clientHandle.close();
    return;
  }

  const socket = new Socket({
    handle: clientHandle,
    allowHalfOpen: self.allowHalfOpen,
    pauseOnCreate: self.pauseOnConnect,
    readable: true,
    writable: true
  });

  self._connections++;
  socket.server = self;
  socket._server = self;

  DTRACE_NET_SERVER_CONNECTION(socket);
+  self.emit('connection', socket);
}
```


创建一个TCP的服务器，connectionListener 的回参是一个socket的实例，通过监听这个实例的 data 事件，在有数据到来时会触发事件的回调函数


会触发到 ‘request’ 事件的位置，是 parserOnIncoming 函数

```js
// The following callback is issued after the headers have been read on a
// new message. In this callback we setup the response object and pass it
// to the user.
function parserOnIncoming(server, socket, state, req, keepAlive) {
  resetSocketTimeout(server, socket, state);

  if (req.upgrade) {
    req.upgrade = req.method === 'CONNECT' ||
                  server.listenerCount('upgrade') > 0;
    if (req.upgrade)
      return 2;
  }

  ArrayPrototypePush(state.incoming, req);

  // If the writable end isn't consuming, then stop reading
  // so that we don't become overwhelmed by a flood of
  // pipelined requests that may never be resolved.
  if (!socket._paused) {
    const ws = socket._writableState;
    if (ws.needDrain || state.outgoingData >= socket.writableHighWaterMark) {
      socket._paused = true;
      // We also need to pause the parser, but don't do that until after
      // the call to execute, because we may still be processing the last
      // chunk.
      socket.pause();
    }
  }

  const res = new server[kServerResponse](req);
  res._keepAliveTimeout = server.keepAliveTimeout;
  res._onPendingData = FunctionPrototypeBind(updateOutgoingData, undefined,
                                             socket, state);

  res.shouldKeepAlive = keepAlive;
  DTRACE_HTTP_SERVER_REQUEST(req, socket);

  if (onRequestStartChannel.hasSubscribers) {
    onRequestStartChannel.publish({
      request: req,
      response: res,
      socket,
      server
    });
  }

  if (socket._httpMessage) {
    // There are already pending outgoing res, append.
    ArrayPrototypePush(state.outgoing, res);
  } else {
    res.assignSocket(socket);
  }

  // When we're finished writing the response, check if this is the last
  // response, if so destroy the socket.
  res.on('finish',
         FunctionPrototypeBind(resOnFinish, undefined,
                               req, res, socket, state, server));

  if (req.headers.expect !== undefined &&
      (req.httpVersionMajor === 1 && req.httpVersionMinor === 1)) {
    if (RegExpPrototypeTest(continueExpression, req.headers.expect)) {
      res._expect_continue = true;

      if (server.listenerCount('checkContinue') > 0) {
        server.emit('checkContinue', req, res);
      } else {
        res.writeContinue();
        server.emit('request', req, res);
      }
    } else if (server.listenerCount('checkExpectation') > 0) {
      server.emit('checkExpectation', req, res);
    } else {
      res.writeHead(417);
      res.end();
    }
  } else {
    req.on('end', clearRequestTimeout);

    server.emit('request', req, res);
  }
  return 0;  // No special treatment.
}
```
parseOnIncoming 绑定上下文之后，挂在 parser 上：
```js
parser.onIncoming = FunctionPrototypeBind(parserOnIncoming, undefined, server, socket, state);
```


## QA

1. 启动http服务监听了一个端口。http的实例是继承自net.Server，所以会不会http层面占用一个端口、tcp层面又占用一个？

不会! `_http_server.js` 中的 `Server`类可以发现是没有 `listen` 这个方法的，而是使用 继承自 `net.Server`的 `listen` 方法